# JavaScript

## Efficient Static Vulnerability Analysis for JavaScript with Multiversion Dependency Graphs，2024，CCF-A

{% embed url="https://dl.acm.org/doi/10.1145/3656394" %}

{% embed url="https://github.com/formalsec/graphjs" %}

技术路线：提出了一种对CDG图的轻量级改进设计：**Multiversion Dependency Graph (MDG)** ，采用图查询匹配（非机器学习）来实现四种漏洞的检测

#### **MDG的结构与组成（还有点没看懂）**

**(1) 节点类型**

* **对象节点（Object Node）**
  * 表示程序执行过程中创建的对象或原始值。
  * 标签格式：`𝑜𝑥 :𝑣~`（如 `𝑜5:config[op]`），其中：
    * `𝑜𝑥`：对象版本标识符。
    * `𝑣~`：源代码中指向该对象的变量名或属性路径。
  * **动态属性**：用通配符 `*` 表示未知属性名（如 `𝑜1 P(*)→𝑜5`）。
* **函数调用节点（Function Call Node）**
  * 表示函数调用（如 `exec()`）。
  * 标签格式：`𝑓𝑥 :𝑣~()`（如 `𝑓1:exec()`）。

**(2) 边类型**

* **属性边（Property Edge, `P(p)`）**
  * 表示对象属性的内部结构（如 `𝑜1 P(*)→𝑜5`）。
  * 边标签 `p` 为属性名，`*` 表示动态属性。
* **版本边（Version Edge, `V(p)`）**
  * 表示对象版本更新（如 `𝑜5 V(*)→𝑜6`）。
  * 新版本继承旧版本属性，并记录属性变更（如动态属性添加）。
* **依赖边（Dependency Edge, `D`）**
  * 表示数据依赖关系，包括：
    1. **动态属性名依赖**（如 `𝑜3 D→𝑜6`，分支名动态影响属性名）。
    2. **属性值到函数调用的依赖**（如 `𝑜8 D→𝑓1`，`options.cmd` 影响 `exec()` 参数）。

<figure><img src="../../.gitbook/assets/image (97).png" alt=""><figcaption></figcaption></figure>

实现了四种Java漏洞的检测，**检测的四种漏洞分类与对比：**

| **漏洞类型**             | **所属类别** | **关键特征**        | **典型防御手段**   |
| -------------------- | -------- | --------------- | ------------ |
| Prototype Pollution  | 对象原型篡改   | 污染JavaScript原型链 | 冻结原型、过滤敏感键   |
| OS Command Injection | 污点式漏洞    | 拼接不可信数据到系统命令    | 参数化命令、输入白名单  |
| Arbitrary Code Exec  | 污点式漏洞    | 动态执行用户输入的代码     | 禁用eval、沙箱隔离  |
| Path Traversal       | 污点式漏洞    | 利用路径跳转符访问受限文件   | 路径规范化、目录权限控制 |

***

* **原型污染**：针对JavaScript原型链的篡改，需警惕动态对象操作。
* **污点式漏洞**：核心是**数据流未净化**，需对输入输出严格管控。
  * **OS命令注入**：关注命令拼接与特殊字符过滤。
  * **任意代码执行**：避免动态执行不可信代码。
  * **路径遍历**：规范化路径并限制文件访问范围。





## Project Achilles: A Prototype Tool for Static Method-Level Vulnerability Detection of Java Source Code Using a Recurrent Neural Network，2019，CCF-A

{% embed url="https://ieeexplore.ieee.org/abstract/document/8967427" %}

{% embed url="https://gitlab.com/TUSoftwareEngineering/vulnerability-localization-using-machine-learning" %}

技术路线：LSTM+RNN，实现了29种类型的漏洞检测，在24种漏洞中准确率都高于90%

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

## GNNDroid: Graph-Learning Based Malware Detection for Android Apps With Native Code，2024，CCF-A

原文：

{% embed url="https://ieeexplore.ieee.org/document/10638211" %}

提取Java function call graphs **(Java FCGs)** 和 native function call graphs **(native FCGs)**，**Multi-Relational Directed Graphs (MRDGs)+Gated Graph Neural Network (GGNN)**

{% hint style="info" %}
“**Native code**” 是指用与设备处理器直接兼容的低层语言（如 **C** 或 **C++**）编写并编译后的机器码，它绕过虚拟机，**可以直接在操作系统上运行**。在 Android 平台上，native code 通常以 `.so`（共享对象）库的形式存在，是通过 **NDK（Native Development Kit）** 编写的，也就是第三方库和SDKs
{% endhint %}

### 问题提出

**Android 恶意软件检测中“缺乏跨语言静态分析能力”的核心问题**：现有的Android恶意软件分析工具缺少对native code中恶意行为的分析——恶意行为可以隐藏在 native code 中，而在 Java 层保持“无害”外观，从而绕过 Android 的安全检测机制。

并且提出现有的恶意软件检测工具分类

* _Keyword-Based tools_（如 Drebin）_：手工特征工程+SVM等机器学习算法，比较古老_
* _API-Based Tools_（如 MAMADroid、TaintDroid）_：_
  * _代表性baseline算法MAMADroid：提取API函数，分析调用关系，构建马尔可夫链来对APP进行建模，然后使用随机森林Random Forest学习分类_
  * 由于 native 层 API 与 Java 层差异大，语义难以跨语言迁移将这类方式扩展到native code的恶意行为检测
* _Graph-Learning-Based Tools：使用先进的图机器学习算法，代表方法MsDroid从CG图中提取子图使用GNN进行分析_
* _Inter-Language Analysis Tools：这类方法同时分析Java和native code，但是使用的方法都是追踪敏感信息，_&#x805A;焦在信息泄露检测，需要人工判断

为了应对跨语言恶意代码检测中的代码异构性、调用关系复杂和语义信息缺失三大挑战，本文提出了一种基于图神经网络的跨语言恶意软件检测框架——GNNDroid。该系统主要分为三个阶段：

* 函数调用图（FCG）生成阶段\
  GNNDroid使用工具Apktool分别从Java代码（.dex文件、Manifest等）和native代码（.so文件）中提取函数及其调用关系，分别构建Java和Native函数调用图（FCGs）。Java端通过基于**Activity**的函数调用图生成方式，这里的**Activity** 指的是 **Android 应用中的 `Activity` 组件**，这是 Android 应用的四大核心组件之一（Activity、Service、BroadcastReceiver、ContentProvider），**以应用中定义的 Activity 为起点**，提取其生命周期函数和内部函数调用，进一步**分析这些函数之间的调用关系。**&#x4E;ative端使用Radare2分析二进制调用关系，并补充跨文件间的调用链接。每个函数节点包含原型和实现，边则记录调用方向、参数和边类型（边类型一共有四种，表示被调和调用者函数之间是否跨语言，在当前步骤分析出非跨语言的两种调用关系：J2J/N2N）。
* 图融合阶段\
  GNNDroid进一步融合Java与Native的调用图，构建多关系有向图（MRDG）。为识别跨语言函数调用关系，它使用基于正则表达式的方法提取JNI调用中的函数名和库名（Java调用Native）或Java包类方法信息（Native调用Java），从而建立跨语言边（类型2和3）并融合生成完整MRDG图。

{% hint style="info" %}
JNI：Java Native Interface，

在Java层面，开发者在调用Native函数时需要先通过JNI声明，通过 JNI 调用的函数通常遵循 _**native\_library\_name + Java\_class + native\_function\_name**_ 的命名模式，GNNDroid通过这个命名模式来识别Native function name和native library name

在Native层面，开发者通过 JNIEnv 访问 Java 对象或调用 Java 函数。根据 JNI 标准，通过 JNI 调用的函数遵循 _**Java\_package\_class\_method**_ 的命名模式，GNNDROID 采用正则表达式匹配来识别 Java 包、Java 类和 Java 方法原型
{% endhint %}

* 图学习阶段\
  GNNDroid将MRDG向量化处理：首先提取节点的函数级特征（Java与Native共20种），再使用Word2Vec向量化边的语义信息。随后，利用\*\*门控图神经网络（GGNN）\*\*进行图的学习与分类建模。GGNN通过多轮信息传递与更新，捕捉节点间复杂关系，实现恶意软件的判别。

综上，GNNDroid通过构建和学习Java与Native代码混合行为的多关系图结构，有效融合了语义信息与结构信息，在跨语言场景下实现了鲁棒的恶意软件检测。



GNNDroid研究的贡献点如下：

* a) 贡献点1：论文针对移动应用中Java与Native代码联动造成的恶意行为检测难题，提出了GNNDroid方法，通过构建跨语言的多关系有向图，实现了对Java与Native代码中恶意行为的联合检测；
* b) 贡献点2：论文针对现有方法难以有效建模跨语言恶意行为模式的问题，提出基于图学习的跨语言恶意软件检测方法，采用Gated Graph Neural Network（GGNN）对多关系函数调用图进行建模，实现了跨语言恶意行为的精准识别；
* c) 贡献点3：论文针对现有方法特征提取效率低、依赖人工维护的问题，提出一种可扩展且高效的恶意软件检测工具，自动提取提取Java function call graphs (Java FCGs) 和 native function call graphs (native FCGs)组成Multi-Relational Directed Graphs (MRDGs)并在4万移动应用中验证其有效性，F1值达98.57%，显著优于现有工具。
